Include: include/setup.vader

Execute (printf 1):
  let maker = {'exe': 'printf', 'args': ['1']}
  CallNeomake 0, [maker]
  AssertEqual map(getqflist(), 'v:val.text'), ['1']

Execute (shell options):
  Log neomake#utils#redir('verb set shell?')
  Log neomake#utils#redir('verb set shellcmdflag?')
  Log '+shellslash: '.exists('+shellslash')
  if exists('+shellslash')
    Log '&shellslash: '.neomake#utils#redir('verb set shellslash?')
  endif

" Execute (g:NeomakeTestsCreateExe):
"   let exe = g:NeomakeTestsCreateExe('foo', ['#!/bin/sh', 'printf 1'])
"   Log 'exe: '.exe
"   let exe_path = exepath('foo')
"   Log exe_path
"   AssertEqual system(exe), "1"
"   Assert len(exe_path)
"
" Execute (g:NeomakeTestsCreateExe: cmd):
"   let exe = g:NeomakeTestsCreateExe('foo.cmd', ['#!/bin/sh', 'printf 1'])
"   Log 'exe: '.exe
"   let exe_path = exepath('foo')
"   Log exe_path
"   let exe_path = exepath('foo.cmd')
"   Log exe_path
"   AssertEqual system(exe), "1"
"   Assert len(exe_path)

Execute (g:NeomakeTestsCreateExe):
  let exe = g:NeomakeTestsCreateExe('foo', ['printf 1'])
  AssertEqual system(exe), "1"
  if neomake#utils#IsRunningWindows()
    " Creates a wrapper .cmd script.
    Log exepath('foo')
    Log exepath('foo.cmd')
    Assert !empty(exepath('foo.cmd'))
  endif
  AssertEqual system(exe), "1"
  Assert !empty(exepath('foo'))

Execute (g:NeomakeTestsCreateExe: sh):
  let exe = g:NeomakeTestsCreateExe('foo.sh', ['#!/bin/sh', 'printf 1'])
  Log 'exe: '.exe
  let exe_path = exepath('foo')
  Log exe_path
  let exe_path = exepath('foo.sh')
  Log exe_path
  AssertEqual system(exe), "1"
  Assert len(exe_path)

Execute (g:NeomakeTestsCreateExe: win cmd):
  if neomake#utils#IsRunningWindows()
    let exe = g:NeomakeTestsCreateExe('foo.cmd', ['@echo off', 'echo 1'])
    AssertEqual fnamemodify(exepath('foo.CMD'), ':t'), 'foo.CMD'
    AssertEqual fnamemodify(exepath('foo'), ':t'), 'foo.CMD'
    AssertEqual fnamemodify(exepath('foo.cmd'), ':t'), 'foo.cmd'
  else
    let exe = g:NeomakeTestsCreateExe('foo.cmd', ['echo 1'])
    AssertEqual fnamemodify(exepath('foo.cmd'), ':t'), 'foo.cmd'
  endif
  AssertEqual system(exe), "1\n"

Execute (escaping):
  function! s:run_cmd(cmd)
    let s:exit = []

    Log '== cmd: '.a:cmd

    if exists('*job_start')
      let s:output = ''
      let s:err = ''
      let s:closed = 0
      unlet! s:exit

      function! s:output(channel, data)
        let s:output .= a:data
      endfunction

      function! s:err(channel, data)
        let s:err .= a:data
      endfunction

      function! s:exit(job, status)
        let s:exit = a:status
      endfunction

      function! s:close_cb(channel)
        while ch_status(a:channel, {'part': 'out'}) == 'buffered'
          sleep 10m
        endwhile
        let s:closed = 1
      endfunction

      let job = job_start(a:cmd, {
      \ 'out_cb': function('s:output'),
      \ 'err_cb': function('s:err'),
      \ 'exit_cb': function('s:exit'),
      \ 'close_cb': function('s:close_cb'),
      \ 'out_mode': 'raw',
      \ 'err_mode': 'raw',
      \ })

      while empty(s:closed)
        sleep 10m
      endwhile
      return [s:output, s:err, s:exit]
    else
      let job = {'output': [''], 'err': ['']}

      function! job.on_stdout(_job_id, data, _event)
      Log a:data
        let self.output[-1] .= a:data[0]
        call extend(self.output, a:data[1:])
      endfunction

      function! job.on_stderr(_job_id, data, _event)
        let self.err[-1] .= a:data[0]
        call extend(self.err, a:data[1:])
      endfunction

      function! job.on_exit(_job_id, data, _event)
        let self.exit = a:data
      endfunction

      call jobwait([jobstart(a:cmd, job)])
      return [join(job.output, "\n"), join(job.err, "\n"), job.exit]
    endif
    return [our, err]
  endfunction

  AssertEqual s:run_cmd('bash -c "printf 1"'), ['1', '', 0]
  AssertEqual s:run_cmd('bash -c "echo 1; echo 2"'), ["1\n2\n", '', 0]

  if neomake#utils#IsRunningWindows()
    AssertEqual s:run_cmd('cmd /c "echo 1"'), ["1\r\n", '', 0]
    AssertEqual s:run_cmd('cmd /c "echo 1; echo 2"'), ["1; echo 2\r\n", '', 0]
    AssertEqual s:run_cmd('cmd /c echo 1'), ["1\r\n", '', 0]
    AssertEqual s:run_cmd('cmd /c echo 1 2'), ["1 2\r\n", '', 0]

    " cmd.exe with parenthesis.
    AssertEqual s:run_cmd('cmd /c (echo 1 2)'), ["1 2\r\n", '', 0]
    AssertEqual s:run_cmd('cmd /c (echo "1 ''2''")'), ["\"1 '2'\"\r\n", '', 0]

    " bash with parenthesis (does not work).
    " AssertEqual s:run_cmd('bash -c (echo "1 ''2''")'), ["\"1 '2'\"\r\n", '', 0]
    " AssertEqual s:run_cmd('bash -c (echo "1 ''2''";)'), ["\"1 '2'\"\r\n", '', 0]

    AssertEqual s:run_cmd('cmd.exe /c echo "1 1"'), ["\"1 1\"\r\n"]
  endif

  AssertEqual s:run_cmd('bash -c "printf ''%s'' 1 2"'), ['12', '', 0]
  AssertEqual s:run_cmd('bash -c "printf ''%s\n'' 1 2"'), ["1\n2\n", '', 0]
