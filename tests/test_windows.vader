Include: include/setup.vader

Execute (shell options):
  Log neomake#utils#redir('verb set shell?')
  Log neomake#utils#redir('verb set shellcmdflag?')
  Log '+shellslash: '.exists('+shellslash')
  if exists('+shellslash')
    Log '&shellslash: '.neomake#utils#redir('verb set shellslash?')
  endif

Execute (printf 1):
  let maker = {'exe': 'printf', 'args': ['1']}
  CallNeomake 0, [maker]
  AssertEqual map(getqflist(), 'v:val.text'), ['1']

" Execute (g:NeomakeTestsCreateExe):
"   let exe = g:NeomakeTestsCreateExe('foo', ['#!/bin/sh', 'printf 1'])
"   Log 'exe: '.exe
"   let exe_path = exepath('foo')
"   Log exe_path
"   AssertEqual system(exe), "1"
"   Assert len(exe_path)
"
" Execute (g:NeomakeTestsCreateExe: cmd):
"   let exe = g:NeomakeTestsCreateExe('foo.cmd', ['#!/bin/sh', 'printf 1'])
"   Log 'exe: '.exe
"   let exe_path = exepath('foo')
"   Log exe_path
"   let exe_path = exepath('foo.cmd')
"   Log exe_path
"   AssertEqual system(exe), "1"
"   Assert len(exe_path)

Execute (g:NeomakeTestsCreateExe):
  let exe = g:NeomakeTestsCreateExe('foo', ['printf 1'])
  AssertEqual system(exe), "1"
  if neomake#utils#IsRunningWindows()
    " Creates a wrapper .cmd script.
    Log exepath('foo')
    Log exepath('foo.cmd')
    Assert !empty(exepath('foo.cmd'))
  endif
  AssertEqual system(exe), "1"
  Assert !empty(exepath('foo'))

Execute (g:NeomakeTestsCreateExe: sh):
  let exe = g:NeomakeTestsCreateExe('foo.sh', ['#!/bin/sh', 'printf 1'])
  Log 'exe: '.exe
  let exe_path = exepath('foo')
  Log exe_path
  let exe_path = exepath('foo.sh')
  Log exe_path
  AssertEqual system(exe), "1"
  Assert len(exe_path)

Execute (g:NeomakeTestsCreateExe: win cmd):
  if neomake#utils#IsRunningWindows()
    let exe = g:NeomakeTestsCreateExe('foo.cmd', ['@echo off', 'echo 1'])
    AssertEqual fnamemodify(exepath('foo.CMD'), ':t'), 'foo.CMD'
    if has('nvim')
      " With &shell == 'cmd.exe' at least.
      AssertEqual fnamemodify(exepath('foo'), ':t'), 'foo'
    else
      AssertEqual fnamemodify(exepath('foo'), ':t'), 'foo.CMD'
    endif
    AssertEqual fnamemodify(exepath('foo.cmd'), ':t'), 'foo.cmd'
  else
    let exe = g:NeomakeTestsCreateExe('foo.cmd', ['echo 1'])
    AssertEqual fnamemodify(exepath('foo.cmd'), ':t'), 'foo.cmd'
  endif
  AssertEqual system(exe), "1\n"

Execute (escaping):
  function! s:run_cmd(cmd)
    let s:exit = []

    Log '== cmd: '.(type(a:cmd) == type('') ? a:cmd : string(a:cmd))

    if exists('*job_start')
      let s:output = ''
      let s:err = ''
      let s:closed = 0
      unlet! s:exit

      function! s:output(channel, data)
        let s:output .= a:data
      endfunction

      function! s:err(channel, data)
        let s:err .= a:data
      endfunction

      function! s:exit(job, status)
        let s:exit = a:status
      endfunction

      function! s:close_cb(channel)
        while ch_status(a:channel, {'part': 'out'}) == 'buffered'
          sleep 10m
        endwhile
        let s:closed = 1
      endfunction

      let job = job_start(a:cmd, {
      \ 'out_cb': function('s:output'),
      \ 'err_cb': function('s:err'),
      \ 'exit_cb': function('s:exit'),
      \ 'close_cb': function('s:close_cb'),
      \ 'out_mode': 'raw',
      \ 'err_mode': 'raw',
      \ })

      while empty(s:closed)
        sleep 10m
      endwhile
      return [s:output, s:err, s:exit]
    else
      let job = {'output': [''], 'err': ['']}

      function! job.on_stdout(_job_id, data, _event)
      Log a:data
        let self.output[-1] .= a:data[0]
        call extend(self.output, a:data[1:])
      endfunction

      function! job.on_stderr(_job_id, data, _event)
        let self.err[-1] .= a:data[0]
        call extend(self.err, a:data[1:])
      endfunction

      function! job.on_exit(_job_id, data, _event)
        let self.exit = a:data
      endfunction

      call jobwait([jobstart(a:cmd, job)])
      return [join(job.output, "\n"), join(job.err, "\n"), job.exit]
    endif
    return [our, err]
  endfunction

  AssertEqual s:run_cmd('bash -c "printf 1"'), ['1', '', 0]
  AssertEqual s:run_cmd('bash -c "echo 1; echo 2"'), ["1\n2\n", '', 0]

  if neomake#utils#IsRunningWindows()
    AssertEqual s:run_cmd('cmd /c "echo 1"'), ["1\r\n", '', 0]
    AssertEqual s:run_cmd('cmd /c "echo 1; echo 2"'), ["1; echo 2\r\n", '', 0]
    AssertEqual s:run_cmd('cmd /c echo 1'), ["1\r\n", '', 0]
    AssertEqual s:run_cmd('cmd /c echo 1 2'), ["1 2\r\n", '', 0]

    " cmd.exe with parenthesis.
    AssertEqual s:run_cmd('cmd /c (echo 1 2)'), ["1 2\r\n", '', 0]
    AssertEqual s:run_cmd('cmd /c (echo "1 ''2''")'), ["\"1 '2'\"\r\n", '', 0]

    " bash with parenthesis (does not work).
    " AssertEqual s:run_cmd('bash -c (echo "1 ''2''")'), ["\"1 '2'\"\r\n", '', 0]
    " AssertEqual s:run_cmd('bash -c (echo "1 ''2''";)'), ["\"1 '2'\"\r\n", '', 0]

    AssertEqual s:run_cmd('cmd.exe /c echo "1 1"'), ["\"1 1\"\r\n", '', 0]
  endif

  AssertEqual s:run_cmd('bash -c "printf ''%s'' 1 2"'), ['12', '', 0]

  if has('nvim')
    AssertEqual s:run_cmd(['bash', '-c', "printf '%s\n' 1 2"]), ["1\n2\n", '', 0]
    AssertEqual s:run_cmd('bash -c "printf ''%s\n'' 1 2"'), ["1\n2\n", '', 0]
  else
    " XXX
    AssertEqual s:run_cmd('bash -c "printf ''%s\n'' 1 2"'), ["1\n2\n", '', 0]
    " XXX
    AssertEqual s:run_cmd(['bash', '-c', 'printf "%s\n" 1 2']), ["1\n2\n", '', 0]
  endif

Execute (tempname):
  let tmpdir = tempname()
  Log tmpdir

Execute (… (ellipsis)):
  " Neovim on Windows:
  " Calling User autocmd NeomakeCountsChanged with context: {'jobinfo': 'ΓÇª', 'reset': 0}.
  Log '…'
  Log "…"

Execute (fnamemodify):
  if neomake#utils#IsRunningWindows()
    AssertEqual fnamemodify('/doesnotexist', ':p'), 'C:\doesnotexist'
  else
    AssertEqual fnamemodify('/doesnotexist', ':p'), '/doesnotexist'
  endif

Execute (mkdir, writefile):
  new
  let tmp = tempname()
  call mkdir(tmp, 'p')
  Log tmp
  exe 'lcd '.tmp

  if has('nvim') && (!exists('+shellslash') || &shellslash)
    " Vim(call):E739: Cannot create directory: pylama/subdir
    call mkdir('pylama/subdir', 'p')
  else
    call mkdir('pylama\subdir', 'p')
  endif
  call writefile([], 'pylama/setup.cfg')
  lcd pylama/subdir
  Log getcwd()
  Log filereadable('../setup.cfg')
  Log neomake#utils#FindGlobFile('{pylama.ini,setup.cfg,tox.ini,pytest.ini}')
  Log neomake#utils#FindGlobFile('setup.cfg')
  bwipe

Execute (NeomakeTestsCommandMaker with semicolons):
  new
  Save &shell
  let &shell = 'cmd'
  let maker = NeomakeTestsCommandMaker('cmd-with-;', 'echo 1; echo 2')
  Log maker
  CallNeomake 1, [maker]
  AssertEqual map(getloclist(0), 'v:val.text'), ['1', '2']
  bwipe


Execute (out of tests/makers.vader: Neomake/Neomake! run ft maker in project mode):
  call g:NeomakeSetupAutocmdWrappers()
  new
  edit tests/fixtures/a\ filename\ with\ spaces
  set ft=neomake_tests
  let fname = bufname('%')

  Neomake echo_args
  NeomakeTestsWaitForFinishedJobs
  AssertNeomakeMessage 'Running makers: echo_args.'
  AssertEqual map(getloclist(0), 'v:val.text'), [fname]

  Neomake! echo_args
  NeomakeTestsWaitForFinishedJobs
  AssertNeomakeMessage 'Running makers: echo_args.'
  AssertEqual map(getqflist(), 'v:val.text'), ['']

  call neomake#config#set('b:append_file', 1)
  CallNeomake 0, ['echo_args']
  AssertNeomakeMessage 'Running makers: echo_args.'
  AssertNeomakeMessage "Using setting append_file=1 from 'buffer'.", 3
  AssertEqual map(getqflist(), 'v:val.text'), [fname]

  AssertEqual map(getloclist(0), 'v:val.text'), [fname]

  AssertEqual map(copy(g:neomake_test_jobfinished), 'v:val.jobinfo.file_mode'), [1, 0, 0]
  bwipe
