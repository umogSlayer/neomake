Include: include/setup.vader

Execute (maker.args as list gets escaped):
  let maker = {
        \ 'exe': 'printf',
        \ 'args': ['%s\n', '1', '2', '3a 3b'],
        \ 'errorformat': '%f: %m',
        \ 'mapexpr': 'expand("%:p") . ": " . v:val',
        \ }

  new
  let fname = neomake#utils#fname('tests', 'fixtures', 'a filename with spaces')
  exe 'edit '.fnameescape(fname)
  let fname = bufname('%')

  call neomake#Make(1, [maker])
  NeomakeTestsWaitForFinishedJobs
  AssertEqual map(getloclist(0), 'v:val.text'),
    \ ['1', '2', '3a 3b', fname]
  bwipe

Execute (maker.args as string gets not escaped):
  let maker = {
        \ 'exe': 'printf',
        \ 'args': "'%s\\n' 1 2 '3a 3b' 4",
        \ 'errorformat': '%f: %m',
        \ 'mapexpr': 'expand("%:p") . ": " . v:val',
        \ }

  new
  let fname = neomake#utils#fname('tests', 'fixtures', 'a filename with spaces')
  exe 'edit '.fnameescape(fname)

  call neomake#Make(1, [maker])
  NeomakeTestsWaitForFinishedJobs
  AssertEqual map(getloclist(0), 'v:val.text'),
    \ ['1', '2', '3a 3b', '4', fname]
  bwipe

Execute (fname in args gets not expanded (command maker, args as list)):
  let maker = {
        \ 'exe': 'printf',
        \ 'args': ['%s'],
        \ 'errorformat': '%m',
        \ }
  new
  lcd tests/fixtures
  edit ~
  AssertEqual bufname('%'), '~'
  " XXX: '~' gets expanded to $HOME here on MSYS2 with Windows Vim (8.1.1).
  AssertEqual fnamemodify('~', ':.'), '~'
  CallNeomake 1, [maker]
  AssertEqual map(getloclist(0), 'v:val.text'), ['~']
  if neomake#has_async_support()
    if neomake#utils#IsRunningWindows()
      AssertNeomakeMessage 'Starting async job [string]: cmd.exe /s /c printf ""%"s" "~".', 3
    else
      AssertNeomakeMessage "Starting async job: printf '%s' '~'."
    endif
  else
    AssertNeomakeMessage "Starting [string]: printf '%s' '~'."
  endif
  bwipe

Execute (fname in args gets not expanded (command maker, args as string)):
  let maker = {
        \ 'exe': 'printf',
        \ 'args': '%s',
        \ 'errorformat': '%m',
        \ }
  new
  lcd tests/fixtures
  edit ~
  CallNeomake 1, [maker]
  AssertEqual map(getloclist(0), 'v:val.text'), ['~']
  AssertNeomakeMessage '\vStarting .*: .*printf .*\~'
  bwipe

Execute (fname in args gets not expanded (maker from command string)):
  let maker = neomake#utils#MakerFromCommand('printf %s')
  let maker.errorformat = '%m'
  new
  lcd tests/fixtures
  edit ~
  CallNeomake 1, [maker]
  AssertEqual map(getloclist(0), 'v:val.text'), ['~']
  let shell_argv = join(split(&shell) + split(&shellcmdflag))
  if neomake#has_async_support()
    if neomake#utils#IsRunningWindows()
      AssertNeomakeMessage 'Starting async job [string]: cmd.exe /s /c printf %s "~".', 3
    else
      AssertNeomakeMessage "Starting async job: ".shell_argv." 'printf %s '\\''~'\\'''."
    endif
  else
    AssertNeomakeMessage "Starting [string]: ".shell_argv." 'printf %s '\\''~'\\'''."
  endif
  bwipe

Execute (fname in args gets not expanded (maker from command list)):
  let maker = neomake#utils#MakerFromCommand(['printf', '%s'])
  let maker.errorformat = '%m'
  new
  lcd tests/fixtures
  edit ~
  CallNeomake 1, [maker]
  AssertEqual map(getloclist(0), 'v:val.text'), ['~']
  if neomake#has_async_support()
    if neomake#utils#IsRunningWindows()
      AssertNeomakeMessage 'Starting async job [string]: cmd.exe /s /c printf ""%"s" "~".', 3
    else
      AssertNeomakeMessage "Starting async job: printf '%s' '~'."
    endif
  else
    AssertNeomakeMessage "Starting [string]: printf '%s' '~'."
  endif
  bwipe
